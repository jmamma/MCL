/* Copyright 2018, Justin Mammarella jmamma@gmail.com */
#include "MDExploit.h"
#include "MCL.h"

uint8_t last_md_track = 0;
void MDExploit::setup() {}
void MDExploit::setup_global(uint8_t global_num) {
  /** Original position of the global inside the MD (0 to 7). **/
  if (global_num == 0) {
    MD.global.origPosition = 6;
  } else {
    MD.global.origPosition = 7;
  }
  /** Stores the audio output for each track. **/

  for (uint8_t track_n = 0; track_n < 16; track_n++) {
    MD.global.drumRouting[track_n] = mcl_cfg.routing[track_n];
  }

  // baseChannel
  // -- 0
  // 1-4 1
  // 5-8 2
  // 9-12 3
  // 13-16 4

  /** The MIDI base channel of the MachineDrum. **/
  if (global_num == 0) {
    MD.global.baseChannel = 3;
  } else {
    MD.global.baseChannel = 9;
  }

  MD.global.extendedMode = true;
  if (MidiClock.mode == MidiClock.EXTERNAL_MIDI) {
    MD.global.clockIn = false;
    MD.global.clockOut = true;
  } else {
    MD.global.clockIn = true;
    MD.global.clockOut = false;
  }
  MD.global.transportIn = true;
  // some bug
  MD.global.transportOut = true;
  MD.global.localOn = true;
  if ((MidiClock.get_tempo() > 30) && (MidiClock.get_tempo() < 300)) {
    MD.global.tempo = MidiClock.get_tempo() * 24;
  } else {
    MD.global.tempo = 125 * 24;
  }
  MD.global.drumLeft = 16;
  MD.global.drumRight = 16;
  MD.global.programChange = 2;
}
void MDExploit::send_globals() {
  //  if (rec_global) {
  DEBUG_PRINT_FN();
  ElektronDataToSysexEncoder encoder(&MidiUart);
  ElektronDataToSysexEncoder encoder2(&MidiUart);
  setup_global(0);
  // in_sysex = 1;
  MD.global.toSysex(encoder);
  setup_global(1);
  MD.global.toSysex(encoder2);
  // in_sysex = 0;
  //  }
}

void MDExploit::switch_global(uint8_t global_page) {
  DEBUG_PRINT_FN();

  if (global_page == 6) {
    MD.global.baseChannel = 3;
  } else {
    MD.global.baseChannel = 9;
  }
  uint8_t data[] = {0x56, (uint8_t)global_page & 0x7F};
  // in_sysex = 1;
  MD.sendSysex(data, countof(data));
  // in_sysex = 0;
}
bool MDExploit::on(bool switch_tracks) {
  // DEBUG_PRINTLN("Exploit on");
  //  DEBUG_PRINTLN(slowclock);

  // in_sysex = 1;
  if (!MD.connected) {
    return;
  }
  note_interface.note_proceed = false;
  note_interface.init_notes();

  if (state) {
    start_clock = slowclock;
    return false;
  }
  state = true;
  if (ignore_last_track_once) {
    ignore_last_track_once = false;
  } else {
    last_md_track = MD.getCurrentTrack(CALLBACK_TIMEOUT);
  }
  // if (MidiClock.state == 2) {
  // last_md_track = MD.currentTrack;
  MD.clear_all_windows();
  delay(20);
  if ((switch_tracks)) {
    uint8_t n = NUM_MD_TRACKS - 1;
    track_with_nolocks = 255;
    while (n && (track_with_nolocks == 255)) {
      if (mcl_seq.md_tracks[n].lock_mask == 0) {
        track_with_nolocks = n;
      }
      n--;
    }
    if (track_with_nolocks == 255) {
      track_with_nolocks = 15;
    }
    MD.setStatus(0x22, track_with_nolocks);
  }
  //}
  // MD.getBlockingGlobal(0);

  /*if (MidiClock.state == 2) {

    div16th_last = MidiClock.div16th_counter;
    noteproceed = 0;
    }
    else {
    noteproceed = 1;
    }
  */

  note_interface.notecount = 0;
  //   global_new.baseChannel = 9;
  //  ElektronDataToSysexEncoder encoder(&MidiUart);
  //   global_new.toSysex(encoder);
  //    MD.setTempo(MidiClock.tempo);

  int flag = 0;

  //     if ((MidiClock.state == 2) && (MidiClock.mode ==
  //     MidiClock.EXTERNAL_UART2)) {
  if ((MidiClock.state == 2) && (MidiClock.mode == MidiClock.EXTERNAL_UART2)) {
    flag = 1;
  }

  if (flag == 1) {
    MidiUart.m_putc_immediate(MIDI_STOP);
  }
  //   }

  MD.global.baseChannel = 3;

  switch_global(6);

  //     if ((MidiClock.state == 2) &&  (MidiClock.mode ==
  //     MidiClock.EXTERNAL_UART2)) {
  if (flag == 1) {
    MidiUart.m_putc_immediate(MIDI_CONTINUE);
  }
  //    }
  //  MD.getBlockingStatus(MD_CURRENT_GLOBAL_SLOT_REQUEST,200);
  md_exploit_callbacks.setup_callbacks();
  md_exploit_midievents.setup_callbacks();
  start_clock = slowclock;
  return true;
  // note_interface.state = true;
  // in_sysex = 0;
}
bool MDExploit::off(bool switch_tracks) {
  if (!MD.connected) {
    return;
  }
  note_interface.note_proceed = false;
  // DEBUG_PRINTLN("Exploit off");
  //     DEBUG_PRINTLN(slowclock);
  // in_sysex = 1;
  if (!state) {
    return false;
  }
  md_exploit_callbacks.remove_callbacks();
  md_exploit_midievents.remove_callbacks();

  note_interface.state = false;

  //
  //  global_new.tempo = MidiClock.tempo;
  //   global_new.baseChannel = 3;
  //    ElektronDataToSysexEncoder encoder(&MidiUart);
  //   global_new.toSysex(encoder);
  int flag = 0;
  if ((MidiClock.state == 2) && (MidiClock.mode == MidiClock.EXTERNAL_UART2)) {
    flag = 1;
  }
  if (flag == 1) {
    MidiUart.m_putc_immediate(MIDI_STOP);
  }
  //   }
  MD.global.baseChannel = 9;

  switch_global(7);
  //    if ((MidiClock.state == 2) && (MidiClock.mode ==
  //    MidiClock.EXTERNAL_UART2)) {
  if (flag == 1) {
    MidiUart.m_putc_immediate(MIDI_CONTINUE);
  }
  //   }
  DEBUG_PRINTLN("last_md_track");
  DEBUG_PRINTLN(last_md_track);
  if ((switch_tracks)) {
    MD.getCurrentTrack();
    if (MD.currentTrack == track_with_nolocks) {
      MD.setStatus(0x22, last_md_track);
    }
  }
  state = false;
  return true;
  // in_sysex = 0;
}

void MDExploitMidiEvents::setup_callbacks() {
  if (state) {
    return;
  }
  Midi.addOnNoteOnCallback(
      this, (midi_callback_ptr_t)&MDExploitMidiEvents::onNoteOnCallback_Midi);
  Midi.addOnNoteOffCallback(
      this, (midi_callback_ptr_t)&MDExploitMidiEvents::onNoteOffCallback_Midi);
  Midi.addOnControlChangeCallback(
      this,
      (midi_callback_ptr_t)&MDExploitMidiEvents::onControlChangeCallback_Midi);

  state = true;
}

void MDExploitMidiEvents::remove_callbacks() {

  if (!state) {
    return;
  }
  Midi.removeOnNoteOnCallback(
      this, (midi_callback_ptr_t)&MDExploitMidiEvents::onNoteOnCallback_Midi);
  Midi.removeOnNoteOffCallback(
      this, (midi_callback_ptr_t)&MDExploitMidiEvents::onNoteOffCallback_Midi);
  Midi.removeOnControlChangeCallback(
      this,
      (midi_callback_ptr_t)&MDExploitMidiEvents::onControlChangeCallback_Midi);

  state = false;
}
void MDExploitCallbacks::setup_callbacks() {
  if (state) {
    return;
  }
  MidiClock.addOnMidiStopCallback(
      this, (midi_clock_callback_ptr_t)&MDExploitCallbacks::onMidiStopCallback);
  MidiClock.addOnMidiStartCallback(
      this,
      (midi_clock_callback_ptr_t)&MDExploitCallbacks::onMidiStartCallback);
  MidiClock.addOnMidiContinueCallback(
      this,
      (midi_clock_callback_ptr_t)&MDExploitCallbacks::onMidiStartCallback);

  state = true;
};
void MDExploitCallbacks::remove_callbacks() {
  if (!state) {
    return;
  }
  MidiClock.removeOnMidiStopCallback(
      this, (midi_clock_callback_ptr_t)&MDExploitCallbacks::onMidiStopCallback);

  MidiClock.removeOnMidiStartCallback(
      this,
      (midi_clock_callback_ptr_t)&MDExploitCallbacks::onMidiStartCallback);
  MidiClock.removeOnMidiContinueCallback(
      this,
      (midi_clock_callback_ptr_t)&MDExploitCallbacks::onMidiStartCallback);

  state = false;
};

uint8_t MDExploitMidiEvents::note_to_trig(uint8_t note_num) {

  uint8_t trig_num = 0;
  for (uint8_t i = 0; i < sizeof(MD.global.drumMapping); i++) {
    if (note_num == MD.global.drumMapping[i]) {
      trig_num = i;
    }
  }
  return trig_num;
}
void MDExploitMidiEvents::onNoteOnCallback_Midi(uint8_t *msg) {
  if (!note_interface.note_proceed) {
    uint16_t current_clock = slowclock;

    if (clock_diff(md_exploit.start_clock, current_clock) >
        EXPLOIT_DELAY_TIME) {
      note_interface.note_proceed = true;
    }
  }

  if (note_interface.note_proceed) {
    if ((msg[0] == 153)) {
      note_interface.note_on_event(note_to_trig(msg[1]), UART1_PORT);
    }
  }
}
void MDExploitMidiEvents::onNoteOffCallback_Midi(uint8_t *msg) {
  if (note_interface.note_proceed) {
    if ((msg[0] == 153)) {
      note_interface.note_off_event(note_to_trig(msg[1]), UART1_PORT);
    }
  }
}

void MDExploitMidiEvents::onControlChangeCallback_Midi(uint8_t *msg) {
  if ((msg[1] < 120) && (msg[1] > 15)) {
    if (md_exploit.state) {
      route_page.update_globals();
    }
    if (md_exploit.off()) {
      GUI.setPage(&grid_page);
    }
  }
}
void MDExploitCallbacks::onMidiStopCallback() {}
void MDExploitCallbacks::onMidiStartCallback() {
  //     if ((curpage == S_PAGE) || (curpage == W_PAGE) || (curpage == CUE_PAGE)
  //     || (curpage == MIXER_PAGE)) {
  md_exploit.start_clock = slowclock;
  note_interface.note_proceed = false;
  // }
  // mcl_actions.start_clock32th = 0;
}

MDExploit md_exploit;
